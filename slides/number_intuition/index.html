<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Êï∞Â≠óÂ∞∫Â∫¶Êï∞ËΩ¥</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
        }
        .chart-container {
            width: 100%;
            height: 400px; /* Adjust height as needed */
            border: 1px solid #ccc;
            background-color: #fff;
            overflow: hidden; /* Prevent overflow issues during zoom */
            position: relative; /* Needed for tooltip positioning */
            margin-bottom: 10px; /* Space below chart for controls */
            border-radius: 8px; /* Rounded corners for the container */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Subtle shadow */
        }
        .axis path,
        .axis line {
            fill: none;
            stroke: #888; /* Lighter axis line */
            shape-rendering: crispEdges;
        }
        .axis text {
            font-size: 11px; /* Slightly smaller axis text */
            fill: #555;
        }
        .number-bar {
             /* fill and opacity will be set by JS based on category and zoom */
            stroke: none; /* No border for bars */
        }
        .number-icon {
            font-size: 18px; /* Size of the icon */
            text-anchor: middle;
            /* fill will be set by JS based on category */
            cursor: pointer;
            transition: font-size 0.2s ease; /* Smooth font-size transition on hover */
        }
        .number-icon:hover {
            font-size: 24px; /* Enlarge font-size on hover */
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 10px; /* More padding */
            background: rgba(255, 255, 255, 0.95); /* Semi-transparent white */
            border: 1px solid #aaa;
            border-radius: 6px; /* Rounded corners */
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            font-size: 13px; /* Slightly larger tooltip text */
            color: #333;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2); /* Shadow for tooltip */
            z-index: 10;
        }
         .tooltip strong {
             color: steelblue; /* Highlight label */
         }
        .controls {
            text-align: center;
            margin-top: 15px; /* More space above controls */
        }
        .controls button {
            margin: 0 8px; /* More space between buttons */
            padding: 10px 20px; /* Larger buttons */
            font-size: 15px;
            cursor: pointer;
            border: none; /* No default border */
            border-radius: 5px; /* Rounded corners */
            background-color: #5cb85c; /* Green button */
            color: white;
            box-shadow: 0 2px 3px rgba(0,0,0,0.2); /* Button shadow */
            transition: background-color 0.2s ease;
        }
        .controls button:hover {
            background-color: #4cae4c; /* Darker green on hover */
        }
         #zoom-out { background-color: #d9534f; } /* Red button */
         #zoom-out:hover { background-color: #c9302c; } /* Darker red */
         #pan-left, #pan-right { background-color: #f0ad4e; } /* Orange buttons */
         #pan-left:hover, #pan-right:hover { background-color: #ec971f; } /* Darker orange */


        .legend {
            margin-top: 25px; /* More space above legend */
            text-align: center;
            font-size: 13px;
            color: #555;
        }
        .legend-item {
            display: inline-block;
            margin: 0 15px; /* More space between legend items */
        }
        .legend-icon {
            display: inline-block;
            font-size: 18px; /* Icon size in legend */
            margin-right: 5px;
            vertical-align: middle;
        }
        .scale-label {
            font-size: 10px;
            text-anchor: middle;
            fill: #555;
        }
         .unit-marker {
             fill: #bbb; /* Color for unit markers - light grey */
             opacity: 1; /* Full opacity */
             stroke: none;
         }
    </style>
</head>
<body>

    <h2>Êï∞Â≠óÂ∞∫Â∫¶‰∫§‰∫íÊï∞ËΩ¥</h2>
    <p>ÈÄöËøáÊãñÂä®ÂíåÊªöËΩÆÁº©ÊîæÔºåÊàñ‰ΩøÁî®‰∏ãÊñπÊåâÈíÆÂèäÈîÆÁõòÊñπÂêëÈîÆÊù•Êé¢Á¥¢‰∏çÂêåÊï∞Â≠óÁöÑÁõ∏ÂØπ‰ΩçÁΩÆ„ÄÇ</p>
    <div id="chart" class="chart-container"></div>
    <div class="controls">
        <button id="zoom-in">ÊîæÂ§ß (+)</button>
        <button id="zoom-out">Áº©Â∞è (-)</button>
        <button id="pan-left">Â∑¶Áßª (&lt;)</button>
        <button id="pan-right">Âè≥Áßª (&gt;)</button>
    </div>
    <div class="legend" id="legend"></div>
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Data for the number line
        // Each object has:
        // value: The numerical value
        // label: A short label for the number
        // context: A brief description of the number
        // category: The category of the number for coloring and icon
        const numberData = [
            // Removed Units category from here

            // Áâ©ÁêÜÈïøÂ∫¶
            { value: 0.2e-9, label: "Á°ÖÂéüÂ≠êÁõ¥ÂæÑ", context: "Á∫¶ 0.2 nm", category: "Physical Length", icon: "üìè" }, // Ruler emoji
            { value: 2e-9, label: "DNAÁõ¥ÂæÑ", context: "Á∫¶ 2 nm", category: "Physical Length", icon: "üìè" },
            { value: 100e-9, label: "ÁóÖÊØíÂ§ßÂ∞è‰∏äÈôê", context: "Á∫¶ 100 nm", category: "Physical Length", icon: "ü¶†" }, // Microbe emoji
            { value: 5e-6, label: "ÁªÜËèåÂ§ßÂ∞è‰∏äÈôê", context: "Á∫¶ 5 Œºm", category: "Physical Length", icon: "ü¶†" },
            { value: 100e-6, label: "Â§¥ÂèëÁõ¥ÂæÑ‰∏äÈôê", context: "Á∫¶ 100 Œºm", category: "Physical Length", icon: "üíà" }, // Barber pole emoji (represents hair)
            { value: 0.02, label: "ËöÇËöÅÈïøÂ∫¶‰∏äÈôê", context: "Á∫¶ 2 cm", category: "Physical Length", icon: "üêú" }, // Ant emoji
            { value: 2, label: "‰∫∫ÁöÑË∫´È´ò‰∏äÈôê", context: "Á∫¶ 2 m", category: "Physical Length", icon: "üßç" }, // Person standing emoji
            { value: 8.8e3, label: "Áè†Â≥∞È´ò", context: "Á∫¶ 8848 m", category: "Physical Length", icon: "‚õ∞Ô∏è" }, // Mountain emoji
            { value: 70e3, label: "Âú∞Â£≥ÂéöÂ∫¶‰∏äÈôê", context: "Á∫¶ 70 km", category: "Physical Length", icon: "üåç" }, // Earth emoji
            { value: 50e3, label: "Âπ≥ÊµÅÂ±ÇÈ´òÂ∫¶‰∏äÈôê", context: "Á∫¶ 50 km", category: "Physical Length", icon: "‚òÅÔ∏è" }, // Cloud emoji
            { value: 6.4e6, label: "Âú∞ÁêÉÂçäÂæÑ", context: "Á∫¶ 6371 km", category: "Physical Length", icon: "üåé" }, // Earth globe emoji
            { value: 3.8e8, label: "Âú∞ÊúàË∑ùÁ¶ª", context: "Á∫¶ 38‰∏á km", category: "Physical Length", icon: "üåï" }, // Full moon emoji
            { value: 1.5e11, label: "Êó•Âú∞Ë∑ùÁ¶ª", context: "Á∫¶ 1.5‰∫ø km", category: "Physical Length", icon: "‚òÄÔ∏è" }, // Sun emoji
            { value: 1.5e13, label: "Â§™Èò≥Á≥ªÁõ¥ÂæÑ", context: "Á∫¶ 100 AU", category: "Physical Length", icon: "ü™ê" }, // Ringed planet emoji
            { value: 4e16, label: "ÊØîÈÇªÊòüË∑ùÁ¶ª", context: "Á∫¶ 4.2 ÂÖâÂπ¥", category: "Physical Length", icon: "‚≠ê" }, // Star emoji
            { value: 1e21, label: "Èì∂Ê≤≥Á≥ªÁõ¥ÂæÑ", context: "Á∫¶ 10‰∏á ÂÖâÂπ¥", category: "Physical Length", icon: "üåå" }, // Milky Way emoji
            { value: 9e26, label: "ÂèØËßÇÊµãÂÆáÂÆôÁõ¥ÂæÑ", context: "Á∫¶ 930‰∫ø ÂÖâÂπ¥", category: "Physical Length", icon: "üî≠" }, // Telescope emoji

            // Áâ©ÁêÜÊó∂Èó¥
            { value: 1e-18, label: "ÈòøÁßí", context: "ÂÖâÈÄüÁ©øËøáÂéüÂ≠êÊó∂Èó¥", category: "Physical Time", icon: "‚è±Ô∏è" }, // Stopwatch emoji
            { value: 1e-15, label: "È£ûÁßí", context: "ÂéüÂ≠êÊ†∏ÂèçÂ∫îÊó∂Èó¥", category: "Physical Time", icon: "‚è±Ô∏è" },
            { value: 1e-12, label: "ÁöÆÁßí", context: "ÂàÜÂ≠êÊåØÂä®Âë®Êúü", category: "Physical Time", icon: "‚è±Ô∏è" },
            { value: 1e-9, label: "Á∫≥Áßí", context: "CPUÊó∂ÈíüÂë®Êúü", category: "Physical Time", icon: "‚è±Ô∏è" },
            { value: 0.1, label: "Áú®ÁúºÊó∂Èó¥‰∏ãÈôê", context: "Á∫¶ 0.1 s", category: "Physical Time", icon: "üëÅÔ∏è" }, // Eye emoji
            { value: 8.64e4, label: "‰∏ÄÂ§©", context: "Á∫¶ 8.64‰∏á s", category: "Physical Time", icon: "‚òÄÔ∏è" }, // Sun emoji (day)
            { value: 3.15e7, label: "‰∏ÄÂπ¥", context: "Á∫¶ 3150‰∏á s", category: "Physical Time", icon: "üìÖ" }, // Calendar emoji
            { value: 2.5e9, label: "‰∫∫Á±ªÂπ≥ÂùáÂØøÂëΩ", context: "Á∫¶ 80 Âπ¥", category: "Physical Time", icon: "üë§" }, // Bust in silhouette emoji
            { value: 1.6e11, label: "ÊúâÊñáÂ≠óËÆ∞ËΩΩÂéÜÂè≤", context: "Á∫¶ 5000 Âπ¥", category: "Physical Time", icon: "üìú" }, // Scroll emoji
            { value: 3.15e11, label: "ÂÜú‰∏öÊñáÊòéÂè≤", context: "Á∫¶ 1 ‰∏áÂπ¥", category: "Physical Time", icon: "üåæ" }, // Sheaf of rice emoji
            { value: 6.3e12, label: "Êô∫‰∫∫Âá∫Áé∞", context: "Á∫¶ 20 ‰∏áÂπ¥", category: "Physical Time", icon: "üö∂" }, // Person walking emoji
            { value: 6.3e13, label: "ÊóßÁü≥Âô®Êó∂‰ª£ÂºÄÂßã", context: "Á∫¶ 200 ‰∏áÂπ¥", category: "Physical Time", icon: "üóø" }, // Moai emoji (ancient stone)
            { value: 2.1e15, label: "ÊÅêÈæôÁÅ≠Áªù", context: "Á∫¶ 6600 ‰∏áÂπ¥", category: "Physical Time", icon: "ü¶ï" }, // Sauropod emoji
            { value: 1.7e16, label: "ÂØíÊ≠¶Á∫™Â§ßÁàÜÂèë", context: "Á∫¶ 5.4 ‰∫øÂπ¥", category: "Physical Time", icon: "ü¶ë" }, // Squid emoji (represents marine life explosion)
            { value: 1.4e17, label: "Âú∞ÁêÉÂΩ¢Êàê", context: "Á∫¶ 45 ‰∫øÂπ¥", category: "Physical Time", icon: "üåã" }, // Volcano emoji (early Earth)
            { value: 4.3e17, label: "ÂÆáÂÆôÂπ¥ÈæÑ", context: "Á∫¶ 138 ‰∫øÂπ¥", category: "Physical Time", icon: "‚ú®" }, // Sparkles emoji (Big Bang)

            // Á§æ‰ºöÁªèÊµé
            { value: 5e4, label: "Â§ßÂ≠¶Â≠¶ÁîüÊï∞", context: "Á∫¶ 5 ‰∏á‰∫∫", category: "Social/Economy", icon: "üéì" }, // Graduation cap emoji
            { value: 1e6, label: "‰∫ßÂìÅÂπ¥ÈîÄÈáè", context: "Á∫¶ 100 ‰∏á‰ª∂", category: "Social/Economy", icon: "üì¶" }, // Package emoji
            { value: 1e7, label: "ÂüéÂ∏Ç‰∫∫Âè£", context: "Á∫¶ 1000 ‰∏á‰∫∫", category: "Social/Economy", icon: "üèôÔ∏è" }, // Cityscape emoji
            { value: 1.4e9, label: "‰∏≠ÂõΩ‰∫∫Âè£", context: "Á∫¶ 14 ‰∫ø‰∫∫", category: "Social/Economy", icon: "üá®üá≥" }, // China flag emoji
            { value: 8e9, label: "‰∏ñÁïå‰∫∫Âè£", context: "Á∫¶ 80 ‰∫ø‰∫∫", category: "Social/Economy", icon: "üßë‚Äçü§ù‚Äçüßë" }, // People holding hands emoji
            { value: 6e12, label: "ÁæéÂõΩÂπ¥È¢ÑÁÆó", context: "Á∫¶ 6 ‰∏á‰∫øÁæéÂÖÉ", category: "Social/Economy", icon: "üíµ" }, // Dollar banknote emoji
            { value: 2e12, label: "Â§ßÂûãÂÖ¨Âè∏Â∏ÇÂÄº", context: "Á∫¶ 2 ‰∏á‰∫øÁæéÂÖÉ", category: "Social/Economy", icon: "üè¢" }, // Office building emoji
            { value: 1e14, label: "ÂÖ®ÁêÉGDP", context: "Á∫¶ 100 ‰∏á‰∫øÁæéÂÖÉ", category: "Social/Economy", icon: "üí∞" }, // Money bag emoji

            // ËÆ°ÁÆóÊú∫
            { value: 8, label: "1 Byte", context: "8 ÊØîÁâπ", category: "Computer", icon: "üíæ" }, // Floppy disk emoji
            { value: 1e3, label: "1 KB", context: "10^3 Bytes", category: "Computer", icon: "üíæ" },
            { value: 1e6, label: "1 MB", context: "10^6 Bytes", category: "Computer", icon: "üíæ" },
            { value: 1e9, label: "1 GB", context: "10^9 Bytes", category: "Computer", icon: "üíæ" },
            { value: 1e12, label: "1 TB", context: "10^12 Bytes", category: "Computer", icon: "üíæ" },
            { value: 1e15, label: "1 PB", context: "10^15 Bytes", category: "Computer", icon: "üíæ" },
            { value: 1.25e8, label: "GPT-2 Small ÂèÇÊï∞", context: "1.25 ‰∫øÂèÇÊï∞", category: "Computer", icon: "üß†" }, // Brain emoji (AI)
            { value: 1e6, label: "Â§ßÂûãËΩØ‰ª∂‰ª£Á†Å", context: "100 ‰∏áË°å", category: "Computer", icon: "üíª" }, // Laptop emoji
            { value: 3e7, label: "Linux ÂÜÖÊ†∏‰ª£Á†Å", context: "3000 ‰∏áË°å", category: "Computer", icon: "üêß" }, // Penguin emoji (Linux)
             { value: 5e7, label: "Windows ‰ª£Á†Å", context: "5000 ‰∏áË°å", category: "Computer", icon: "ü™ü" }, // Window emoji (Windows)
            { value: 1.75e11, label: "GPT-3 ÂèÇÊï∞", context: "1750 ‰∫øÂèÇÊï∞", category: "Computer", icon: "üß†" },
            { value: 1e12, label: "Â§ßÂûãAIÊ®°ÂûãÂèÇÊï∞", context: "1 ‰∏á‰∫øÂèÇÊï∞", category: "Computer", icon: "üß†" },
        ];

        // Sort data by value for better visualization
        numberData.sort((a, b) => a.value - b.value);

        const margin = { top: 20, right: 30, bottom: 100, left: 60 }; // Increased bottom margin for more scale labels
        const container = d3.select("#chart");
        const containerWidth = container.node().clientWidth;
        const containerHeight = container.node().clientHeight;
        const width = containerWidth - margin.left - margin.right;
        const chartHeight = containerHeight - margin.top - margin.bottom; // Renamed height to chartHeight


        // Append SVG to the container
        const svg = container.append("svg")
            .attr("width", containerWidth)
            .attr("height", containerHeight);

        // Add a transparent rectangle to capture zoom events across the chart area
        const zoomRect = svg.append("rect")
            .attr("width", containerWidth)
            .attr("height", containerHeight)
            .style("fill", "none")
            .style("pointer-events", "all"); // Capture all pointer events

        const g = svg.append("g") // Group for chart elements
            .attr("transform", `translate(${margin.left},${margin.top})`);


        // Create a logarithmic scale for the x-axis
        const x = d3.scaleLog()
            .domain([d3.min(numberData, d => d.value) * 0.01, d3.max(numberData, d => d.value) * 100]) // Add more padding to domain
            .range([0, width]);

        // Create a linear scale for bar height (mapping log value to height)
        const barHeightScale = d3.scaleLinear()
            .domain([Math.log10(d3.min(numberData, d => d.value)), Math.log10(d3.max(numberData, d => d.value))])
            .range([5, chartHeight - 40]); // Map log value to a height range (min height 5px, max height leaving space)


        // Create the x-axis
        const xAxis = g.append("g") // Append axis to the group
            .attr("class", "axis axis--x")
            .attr("transform", `translate(0,${chartHeight})`) // Position at the bottom of chartHeight
            .call(d3.axisBottom(x).ticks(10, ".1e")); // Use scientific notation for ticks

        // Define color scale based on category
        const categories = [...new Set(numberData.map(d => d.category))];
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10) // Use a built-in D3 color scheme
            .domain(categories);

        // --- Overlap Handling (Vertical Offset) ---
        // A more sophisticated stacking logic
        const verticalSpacing = 20; // Increased vertical space between stacked items
        const horizontalTolerance = 6; // Horizontal distance in pixels to consider items "close"

        // Calculate vertical offsets - This needs to be done inside zoomed() based on the current scale
        // Initial calculation outside zoomed() is just for initial render
        function calculateVerticalOffsets(data, xScale, tolerance) {
             // Create a copy to sort without changing original data order
            const sortedData = [...data].sort((a, b) => xScale(a.value) - xScale(b.value));

            const lanes = []; // Array to hold the vertical lanes

            sortedData.forEach(d => {
                const xPos = xScale(d.value);
                let placed = false;

                // Try to place the item in an existing lane
                for (let i = 0; i < lanes.length; i++) {
                    const lane = lanes[i];
                    // Check if this item overlaps horizontally with the last item in the lane
                    if (lane.length === 0 || xPos - lane[lane.length - 1].xPos > tolerance) {
                        // No overlap, place it in this lane
                        d.verticalOffset = i * verticalSpacing;
                        d.xPos = xPos; // Store calculated x position for the current scale
                        lane.push(d);
                        placed = true;
                        break;
                    }
                }

                // If not placed, create a new lane
                if (!placed) {
                    d.verticalOffset = lanes.length * verticalSpacing;
                    d.xPos = xPos; // Store calculated x position for the current scale
                    lanes.push([d]);
                }
            });
             // Update the original data objects with the calculated offsets
             data.forEach(d => {
                 const sortedItem = sortedData.find(item => item.value === d.value);
                 if(sortedItem) {
                     d.verticalOffset = sortedItem.verticalOffset;
                 }
             });
        }

        // Calculate initial offsets
        calculateVerticalOffsets(numberData, x, horizontalTolerance);

        // --- End Overlap Handling ---

        // Add visual markers for scale labels (Units)
        const scaleLabels = [
            { value: 1e-12, cn: "ÁöÆ", en: "Pico" },
            { value: 1e-9, cn: "Á∫≥", en: "Nano" },
            { value: 1e-6, cn: "ÂæÆ", en: "Micro" },
            { value: 1e-3, cn: "ÊØ´", en: "Milli" },
            { value: 1e0, cn: "‰∏™", en: "One" },
            { value: 1e3, cn: "ÂçÉ", en: "Thousand" },
            { value: 1e6, cn: "Áôæ‰∏á", en: "Million" },
            { value: 1e9, cn: "ÂçÅ‰∫ø", en: "Billion" },
            { value: 1e12, cn: "‰∏á‰∫ø (ÂÖÜ)", en: "Trillion" },
            { value: 1e16, cn: "‰∫¨", en: "Quadrillion" }, // Approx
            { value: 1e20, cn: "Âûì", en: "Quintillion" }, // Approx
            { value: 1e24, cn: "Áß≠", en: "Septillion" }, // Approx
            { value: 1e28, cn: "Á©∞", en: "Octillion" }, // Approx
            { value: 1e32, cn: "Ê≤ü", en: "Nonillion" }, // Approx
            { value: 1e36, cn: "Ê∂ß", en: "Decillion" }, // Approx
            { value: 1e40, cn: "Ê≠£", en: "Undecillion" }, // Approx
            { value: 1e44, cn: "ËΩΩ", en: "Duodecillion" }, // Approx
            { value: 1e48, cn: "ÊûÅ", en: "Tredecillion" }, // Approx
            { value: 1e52, cn: "ÊÅíÊ≤≥Ê≤ô", en: "Quattuordecillion" }, // Approx
            { value: 1e56, cn: "ÈòøÂÉßÁ•á", en: "Quindecillion" }, // Approx
            { value: 1e60, cn: "ÈÇ£Áî±‰ªñ", en: "Sexdecillion" }, // Approx
            { value: 1e64, cn: "‰∏çÂèØÊÄùËÆÆ", en: "Septendecillion" }, // Approx
            { value: 1e68, cn: "Êó†ÈáèÂ§ßÊï∞", en: "Octodecillion" }, // Approx
        ];

        const unitMarkers = g.selectAll(".unit-marker") // Append markers to the group
            .data(scaleLabels)
            .enter()
            .append("rect")
            .attr("class", "unit-marker")
            .attr("x", d => x(d.value) - 1) // Position at the value, width 2 (centered)
            .attr("y", 0)
            .attr("width", 2) // Made wider
            .attr("height", chartHeight); // Full height


        // Add Bars for each number
        const bars = g.selectAll(".number-bar") // Append bars to the group
            .data(numberData)
            .enter()
            .append("rect")
            .attr("class", "number-bar")
            .attr("x", d => x(d.value) - 1) // Position bar at the value, width 2
            .attr("width", 2)
            .attr("fill", d => colorScale(d.category)) // Set color based on category
            .attr("y", d => {
                // Bars start from the axis, adjusted by height and vertical offset
                const barHeight = barHeightScale(Math.log10(d.value));
                return chartHeight - barHeight - d.verticalOffset;
            })
            .attr("height", d => {
                // Bars use scaled height
                return barHeightScale(Math.log10(d.value));
            })
            .attr("opacity", 0.7); // Initial opacity


        // Add Icons for each number
        const icons = g.selectAll(".number-icon") // Append icons to the group
            .data(numberData)
            .enter()
            .append("text") // Use text element for emojis/characters
            .attr("class", "number-icon")
            .attr("x", d => x(d.value)) // Position icon at the value
            .attr("y", d => {
                // Position icons based on bar top position + padding
                const barHeight = barHeightScale(Math.log10(d.value));
                const barTopY = chartHeight - barHeight - d.verticalOffset;
                return barTopY - 5; // 5px padding above the bar
            })
            .text(d => d.icon) // Set text to the icon
            .attr("fill", d => colorScale(d.category)) // Set color based on category
            .on("mouseover", function(event, d) {
                // Show tooltip on hover
                d3.select("#tooltip")
                    .style("opacity", 1)
                    .html(`<strong>${d.label}</strong><br>Value: ${d.value.toExponential(2)}<br>Category: ${d.category}<br>${d.context}`) // Show value in scientific notation and category
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 20) + "px");
            })
            .on("mouseout", function() {
                // Hide tooltip on mouseout
                d3.select("#tooltip")
                    .style("opacity", 0);
            });

        // Add Chinese and English scale labels
        const scaleLabelGroup = g.append("g") // Append labels to the group
            .attr("class", "scale-labels")
            .attr("transform", `translate(0,${chartHeight + 30})`); // Position below the axis

        scaleLabelGroup.selectAll(".scale-label")
            .data(scaleLabels)
            .enter()
            .append("text")
            .attr("class", "scale-label")
            .attr("x", d => x(d.value))
            .attr("y", 0) // Position for Chinese label
            .text(d => `${d.cn} / ${d.en}`);

        // Implement Zoom and Pan
        const zoomBehavior = d3.zoom()
            .scaleExtent([1, 100000000000]) // Allow significant zoom
            .translateExtent([[0, 0], [width, chartHeight]]) // Restrict pan
            .on("zoom", zoomed);

        // Apply zoom behavior to the transparent rectangle
        zoomRect.call(zoomBehavior);

        // Store the current transform
        let currentTransform = d3.zoomIdentity;

        function zoomed(event) {
            currentTransform = event.transform; // Update current transform
            const newXScale = event.transform.rescaleX(x); // Rescale the x-axis

            // Update the x-axis based on the new scale
            // The axis itself is appended to 'g', but we update its scale
            xAxis.call(d3.axisBottom(newXScale).ticks(10, ".1e"));


            // Recalculate vertical offsets based on new scale for positioning
            // This is crucial for overlap handling to work correctly with zoom
            calculateVerticalOffsets(numberData, newXScale, horizontalTolerance / (currentTransform.k > 1 ? Math.sqrt(currentTransform.k) : 1));


            // Update bar positions based on the new horizontal scale and recalculated vertical offset
            // X position uses the new scale
            // Y position and Height use static scales and recalculated offset, relative to chartHeight
            bars.attr("x", d => newXScale(d.value) - 1) // Use newXScale for horizontal position
                .attr("y", d => {
                    const barHeight = barHeightScale(Math.log10(d.value));
                    return chartHeight - barHeight - d.verticalOffset; // Y relative to chartHeight
                })
                .attr("height", d => {
                    return barHeightScale(Math.log10(d.value)); // Height is static
                })
                .attr("opacity", Math.min(1, 0.3 + currentTransform.k * 0.1)); // Adjust opacity based on zoom level


            // Update icon positions based on the new horizontal scale and recalculated vertical offset
            icons.attr("x", d => newXScale(d.value)) // Use newXScale for horizontal position
                 .attr("y", d => {
                     const barHeight = barHeightScale(Math.log10(d.value));
                     const barTopY = chartHeight - barHeight - d.verticalOffset;
                     return barTopY - 5; // Y relative to chartHeight
                 })
                 .attr("opacity", Math.min(1, 0.5 + currentTransform.k * 0.1)); // Adjust opacity based on zoom level


            // Update scale label positions based on the new horizontal scale
            scaleLabelGroup.selectAll(".scale-label")
                .attr("x", d => newXScale(d.value)); // Use newXScale for horizontal position
             // Y position is static relative to the group/chart area (set during initial creation)

            // Update unit marker positions based on the new horizontal scale
             unitMarkers.attr("x", d => newXScale(d.value) - 1); // Use newXScale for horizontal position, center the 2px marker
             // Y and height are static relative to the group/chart area (set during initial creation)

            // The main group 'g' itself is not transformed, but its children's attributes are updated.
            // The zoom behavior is applied to zoomRect, which triggers this function.
        }

        // Button event listeners
        d3.select("#zoom-in").on("click", () => {
            svg.transition().duration(500).call(zoomBehavior.scaleBy, 2); // Zoom in by a factor of 2
        });

        d3.select("#zoom-out").on("click", () => {
            svg.transition().duration(500).call(zoomBehavior.scaleBy, 0.5); // Zoom out by a factor of 0.5
        });

        d3.select("#pan-left").on("click", () => {
             // Pan left: move the view left, which means translating the chart content right (positive x)
            svg.transition().duration(500).call(zoomBehavior.translateBy, 100 / currentTransform.k, 0);
        });

        d3.select("#pan-right").on("click", () => {
             // Pan right: move the view right, which means translating the chart content left (negative x)
            svg.transition().duration(500).call(zoomBehavior.translateBy, -100 / currentTransform.k, 0);
        });


        // Add keyboard event listener for panning and zooming
        window.addEventListener('keydown', (event) => {
            const panAmount = 50; // Pixels to pan per key press

            if (event.key === 'ArrowLeft' || event.keyCode === 37) {
                // Pan left
                svg.transition().duration(100).call(zoomBehavior.translateBy, panAmount / currentTransform.k, 0);
                event.preventDefault(); // Prevent default browser scrolling
            } else if (event.key === 'ArrowRight' || event.keyCode === 39) {
                // Pan right
                svg.transition().duration(100).call(zoomBehavior.translateBy, -panAmount / currentTransform.k, 0);
                event.preventDefault(); // Prevent default browser scrolling
            } else if (event.key === 'ArrowUp' || event.keyCode === 38) {
                 // Zoom In
                svg.transition().duration(100).call(zoomBehavior.scaleBy, 1.2); // Zoom in by a factor
                event.preventDefault(); // Prevent default browser scrolling
            } else if (event.key === 'ArrowDown' || event.keyCode === 40) {
                 // Zoom Out
                svg.transition().duration(100).call(zoomBehavior.scaleBy, 1 / 1.2); // Zoom out by a factor
                event.preventDefault(); // Prevent default browser scrolling
            }
        });


        // Add a title to the x-axis
        g.append("text") // Append title to the group
            .attr("transform", `translate(${width/2},${chartHeight + margin.bottom - 10})`) // Position below the axis
            .style("text-anchor", "middle")
            .text("Êï∞ÂÄº (ÂØπÊï∞Â∞∫Â∫¶)");

        // Add Legend
        const legend = d3.select("#legend");
        // Filter out the "Units" category as it's handled separately
        const categoriesForLegend = categories.filter(cat => cat !== "Units");

        categoriesForLegend.forEach(category => {
            // Find an icon for this category from the data
            const sampleData = numberData.find(d => d.category === category);
            const icon = sampleData ? sampleData.icon : '‚óè'; // Default icon if not found

            const legendItem = legend.append("div")
                .attr("class", "legend-item");

            legendItem.append("span")
                .attr("class", "legend-icon")
                .text(icon)
                .style("color", colorScale(category)); // Color the legend icon

            legendItem.append("span")
                .text(category);
        });

        // Add Units category to legend manually since it's not in numberData anymore
         const unitCategory = "Units";
         const unitIcon = "‚óè"; // Using the dot icon for units
         const unitColor = "#bbb"; // Use the color defined in CSS for unit markers
         const unitLegendItem = legend.append("div")
                .attr("class", "legend-item");

         unitLegendItem.append("span")
                .attr("class", "legend-icon")
                .text(unitIcon)
                .style("color", unitColor);

         unitLegendItem.append("span")
                .text(unitCategory);


    </script>

</body>
</html>
