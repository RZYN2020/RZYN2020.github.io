<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Autoboxing and IntegerCache in Java | </title>
<meta name="keywords" content="java, 面试">
<meta name="description" content="
When you are on the dancefloor, there is nothing to do but dance.

—— Umberto Eco, *The Mysterious Flame of Queen Loana*">
<meta name="author" content="">
<link rel="canonical" href="https://rzyn2020.github.io/posts/autoboxing-and-integercache-in-java/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css" integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY&#43;IJWZFnspCg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://rzyn2020.github.io/images/yinyang.webp">
<link rel="icon" type="image/png" sizes="16x16" href="https://rzyn2020.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rzyn2020.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rzyn2020.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rzyn2020.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://rzyn2020.github.io/posts/autoboxing-and-integercache-in-java/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Autoboxing and IntegerCache in Java">
<meta property="og:description" content="
When you are on the dancefloor, there is nothing to do but dance.

—— Umberto Eco, *The Mysterious Flame of Queen Loana*">
<meta property="og:type" content="article">
<meta property="og:url" content="https://rzyn2020.github.io/posts/autoboxing-and-integercache-in-java/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2023-03-07T14:49:32+00:00">
<meta property="article:modified_time" content="2023-03-07T14:49:32+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Autoboxing and IntegerCache in Java">
<meta name="twitter:description" content="
When you are on the dancefloor, there is nothing to do but dance.

—— Umberto Eco, *The Mysterious Flame of Queen Loana*">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://rzyn2020.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Autoboxing and IntegerCache in Java",
      "item": "https://rzyn2020.github.io/posts/autoboxing-and-integercache-in-java/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Autoboxing and IntegerCache in Java",
  "name": "Autoboxing and IntegerCache in Java",
  "description": " When you are on the dancefloor, there is nothing to do but dance.\n—— Umberto Eco, *The Mysterious Flame of Queen Loana*\n",
  "keywords": [
    "java", "面试"
  ],
  "articleBody": " When you are on the dancefloor, there is nothing to do but dance.\n—— Umberto Eco, *The Mysterious Flame of Queen Loana*\n有一道经典的Java面试题：\nInteger i = 100; Integer j = 100; System.out.print(i == j); // true or false? 由于之前没有准备直接上阵，在碰到这道题时一时不解。但显然这是考察autoboxing(自动装箱)机制，而一般整数转化为Integer对象时肯定是new一个新对象，按理说结果应该为false，但是考虑到在具体实现中可能为了效率考虑会预先缓存一部分整数对象，于是便猜测答案为true。下来网上一查，答案果然为true，但解释却是如下：\n这就有点奇怪了——我总觉得缓存多少是具体的编译器或者JVM抑或是相关类库实现的问题，而不该定义在语言规范中，而如果是和具体实现相关的，那么言之凿凿256个数字需要缓存就有点奇怪了。上网查查资料之后，发现256这个数字果然还是Integer类的默认实现中决定的。下面我就综合查找的资料，介绍一下这道题背后可能涉及的知识。\nReference Type 和 Primitive Type 首先Java类型系统以及JVM中，任何 Value(值) 要么是 reference type(引用类型)，要么是 primitive type(基本类型)。所谓reference type就是指向一个对象的值，总是一条new指令的返回值，往往是自身具有一定状态，并可以改变的(mutable)，在JVM实现中为一个指向具体对象的指针；而 primitive type的值 则只能通过字面量或是预先定义的在primitive type上的操作获得，而操作并不改变值本身，只是产生了一个新的值，即是不可变的(immutable)的，在JVM实现中也对应实现语言的primitive type(可以理解为c++中的Int)。\n但是在许多其他面向对象语言中(如Python)，一切皆是对象，一切值皆是引用。这样做比Java好理解许多，具体实现上也易于实现了。但是却带来了效率的低下，这主要有两点原因：\n对于整数这样的在编程中最基本且常用的值，如果每次两数相加都返回一个新对象，则是对资源的极大浪费。 你可能会想：为什么不把整数对象做成单例的？也就是一个只有一个1对象，也只有一个2对象，每次 1 + 1 总能得到同一个2 —— 但注意reference type的特征就是mutable，如果这样就做不到mutable了，和用primitive type表示整数也就没有区别了。 在JVM执行时，遇到引用需要先解引用才能获取整数值，然后再相加，之后封装成整数对象并返回引用，与直接将整数表示为实现语言的primitive type相比效率天差地别。 因此，为了效率考虑，则需要把整数，浮点数等归入primitive type。这样做就又产生了一个问题：在JVM中，一个值即可能是用实现语言的primitive type表示，也可能用指针表示，我们如何对二者进行区分呢？幸好Java是静态类型语言，在编译之后每条指令所操作的值的类型也是确定的。比如当执行iadd指令时栈上存的值就一定为两个整数。但在动态语言中就不一定了，我们必须要先检查类型是否匹配，然后进行操作。此时为了标明一个值究竟是primitive type还是reference type，我们必须把值的高位留出来作为类型tag以示区分。\n// 动态语言虚拟机中的一个值往往是这个样子的 struct Value_t { Type type; union { double number; bool boolean; HeapObject* object; } data; }; Generic 既然有了primitive type的整数，似乎再也不需要作为对象的整数了？看起来似乎是这样，但是Java却依然提供了Integer类表示作为对象的整数——这主要还是因为为了支持泛型的存在。\nJava的泛型是通过类型擦除实现的，也就是泛型信息只在编译期可见，而在运行期(也就是JVM)不可见。无论你是写成List 还是 List ，它们在编译后都会变成同一个List，而这个List存储的是Object对象。\n// 泛型类： public class Box\u003cT\u003e { private T t; public void set(T t) { this.t = t; } public T get() { return t; } } // 上面的泛型类在编译成字节码后 public class org/example/Box { private Ljava/lang/Object; t public \u003cinit\u003e()V ... public set(Ljava/lang/Object;)V ... public get()Ljava/lang/Object; ... } 因为实际上用Object存储，所以每次get都是做了一次强制类型转换，Java编译器会生成CHECKCAST指令来保证类型转换时的正确性。\n// java代码 System.out.println(stringBox.get()); // 编译后的字节码 INVOKEVIRTUAL org/example/Box.get ()Ljava/lang/Object; CHECKCAST java/lang/String INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V 但是如果泛型已经由编译器保证没有类型错误，为什么又要加CHECKCAST指令来运行时再次检查呢？考虑如下泛型程序，在可以通过编译，但在运行时CHECKCAST会报错：\npublic class Main { public static void main(String[] args) { Box stringBox = new Box\u003c\u003e(); stringBox.set(5); foo(stringBox); } public static void foo(Box\u003cString\u003e box) { System.out.println(box.get() + \"123\"); } } //Exception in thread \"main\" java.lang.ClassCastException: class java.lang.Integer cannot be cast to class //java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader 'bootstrap') //\tat org.example.Main.foo(Main.java:14) //\tat org.example.Main.main(Main.java:10) 这是因为Java为了让新代码和没有泛型之前(Java8)的代码兼容，而引入了Raw Type，也就是没有泛型参数的泛型——对这种类型的检查会适当放松——代价就是动态检查的开销。\n当然泛型不仅仅可以通过类型擦除实现，像C++的模板就是走向了另外一个极端——为每个类型都生成相应的类——这样的缺点自然是代码膨胀，好处却是可以动态获取类型信息(C++是否支持反射暂且不论，但如果Java采取和C++一样泛型机制就一定会支持这样的反射的)，不需要动态类型检查，也不需要像Java一样的Integer类。\n好，话题又回到Java的Integer类，正是应为Java的泛型是通过类型擦除实现，所以所有的泛型在背后都有一套统一的表示——也就是Object。但是primitive type却在Java OO继承链之外，也就无法使用泛型了——所有就引入了将primitive type封装成wrapper type的机制。将int封装为Integer即是一个例子。\nAutoboxing and Integer Cache 虽然已经有了wrapper type，但每次手动封装也是非常麻烦的。所以编译就加入了自动检测类型，在合适的时候将primitive type转化为相应的wrapper type，将wrapper type转化为相应的primitive type的机制，也就是“Autoboxing”与“Unboxing”\n所以说，面试题中Integer i = 100;等即采用了Autoboxing 机制，上面的代码在编译处理过之后就等价为下面的代码：\nInteger i = Integer.valueOf(100); Integer j = Integer.valueOf(100); System.out.print(i == j); // true or false? 已知引用比较在java中是直接比较地址，那么我们只需要知道Integer.valueOf做了什么就知道面试题的答案了。\n查阅 java doc，发现:\npublic static Integer valueOf(int i) Returns an Integer instance representing the specified int value. If a new Integer instance is not required, this method should generally be used in preference to the constructor Integer(int), as this method is likely to yield significantly better space and time performance by caching frequently requested values. This method will always cache values in the range -128 to 127, inclusive, and may cache other values outside of this range.\nParameters:\ni - an int value.\nReturns:\nan Integer instance representing i.\nSince:\n1.5\n所以说，除开根据Integer类的实现不同会有不同表现，如果只看标准类库的话那么面试题还没问题的，缓存值的Integer Cache大小总是大于256。但注意到 java doc 中说“may cache other values outside of this range”，这也许就说明还有调节的空间？果然，经查阅，-XX:AutoBoxCacheMax 选项就可以调节Integer Cache的大小。\n在我本机的Open jdk19中，Integer.valueOf实现如下：\n@IntrinsicCandidate public static Integer valueOf(int i) { if (i \u003e= IntegerCache.low \u0026\u0026 i \u003c= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 而用到的IntegerCache类实现如下：\nprivate static class IntegerCache { static final int low = -128; static final int high; static final Integer[] cache; static Integer[] archivedCache; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) { try { h = Math.max(parseInt(integerCacheHighPropValue), 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(h, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; // Load IntegerCache.archivedCache from archive, if possible ... // Use the archived cache if it exists and is large enough ... // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u003e= 127; } ... } 再追踪调用链可以发现VM类表示VM的各种选项，均有System类中的方法设置，但System类中方法又由谁调用，并从哪里知道参数呢？再追踪就会发现，果然这些命令行参数的解析和传入都是通过native method来实现的。\n",
  "wordCount" : "514",
  "inLanguage": "en",
  "datePublished": "2023-03-07T14:49:32Z",
  "dateModified": "2023-03-07T14:49:32Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://rzyn2020.github.io/posts/autoboxing-and-integercache-in-java/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "",
    "logo": {
      "@type": "ImageObject",
      "url": "https://rzyn2020.github.io/images/yinyang.webp"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://rzyn2020.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://rzyn2020.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://rzyn2020.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://rzyn2020.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://rzyn2020.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://rzyn2020.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Autoboxing and IntegerCache in Java
    </h1>
    <div class="post-meta"><span title='2023-03-07 14:49:32 +0000 UTC'>March 7, 2023</span>&nbsp;·&nbsp;3 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#reference-type-%e5%92%8c-primitive-type" aria-label="Reference Type 和 Primitive Type">Reference Type 和 Primitive Type</a></li>
                <li>
                    <a href="#generic" aria-label="Generic">Generic</a></li>
                <li>
                    <a href="#autoboxing--and-integer-cache" aria-label="Autoboxing  and Integer Cache">Autoboxing  and Integer Cache</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>When you are on the dancefloor, there is nothing to do but dance.</p>
</blockquote>
<p style="text-align: right">—— Umberto Eco, *The Mysterious Flame of Queen Loana*</p>
<p>有一道经典的Java面试题：</p>
<div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e06c75">Integer</span> <span style="color:#e06c75">i</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">100</span>;
</span></span><span style="display:flex;"><span><span style="color:#e06c75">Integer</span> <span style="color:#e06c75">j</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">100</span>;
</span></span><span style="display:flex;"><span><span style="color:#e06c75">System</span>.<span style="color:#e06c75">out</span>.<span style="color:#e06c75">print</span>(<span style="color:#e06c75">i</span> <span style="color:#56b6c2">==</span> <span style="color:#e06c75">j</span>); <span style="color:#7f848e">// true or false?</span>
</span></span></code></pre></div><p>由于之前没有准备直接上阵，在碰到这道题时一时不解。但显然这是考察autoboxing(自动装箱)机制，而一般整数转化为Integer对象时肯定是new一个新对象，按理说结果应该为false，但是考虑到在具体实现中可能为了效率考虑会预先缓存一部分整数对象，于是便猜测答案为true。下来网上一查，答案果然为true，但解释却是如下：</p>
<p><img loading="lazy" src="/posts/autoboxing-and-integercache-in-java/img/image-20230307151202637.png"></p>
<p>这就有点奇怪了——我总觉得缓存多少是具体的编译器或者JVM抑或是相关类库实现的问题，而不该定义在语言规范中，而如果是和具体实现相关的，那么言之凿凿256个数字需要缓存就有点奇怪了。上网查查资料之后，发现256这个数字果然还是Integer类的默认实现中决定的。下面我就综合查找的资料，介绍一下这道题背后可能涉及的知识。</p>
<h2 id="reference-type-和-primitive-type">Reference Type 和 Primitive Type<a hidden class="anchor" aria-hidden="true" href="#reference-type-和-primitive-type">#</a></h2>
<p>首先Java类型系统以及JVM中，任何 Value(值) 要么是 reference type(引用类型)，要么是 primitive type(基本类型)。所谓reference type就是指向一个对象的值，总是一条new指令的返回值，往往是自身具有一定状态，并可以改变的(mutable)，在JVM实现中为一个指向具体对象的指针；而 primitive type的值 则只能通过字面量或是预先定义的在primitive type上的操作获得，而操作并不改变值本身，只是产生了一个新的值，即是不可变的(immutable)的，在JVM实现中也对应实现语言的primitive type(可以理解为c++中的Int)。</p>
<p>但是在许多其他面向对象语言中(如Python)，一切皆是对象，一切值皆是引用。这样做比Java好理解许多，具体实现上也易于实现了。但是却带来了效率的低下，这主要有两点原因：</p>
<ul>
<li>对于整数这样的在编程中最基本且常用的值，如果每次两数相加都返回一个新对象，则是对资源的极大浪费。
<ul>
<li>你可能会想：为什么不把整数对象做成单例的？也就是一个只有一个1对象，也只有一个2对象，每次 1 + 1 总能得到同一个2 —— 但注意reference type的特征就是mutable，如果这样就做不到mutable了，和用primitive type表示整数也就没有区别了。</li>
</ul>
</li>
<li>在JVM执行时，遇到引用需要先解引用才能获取整数值，然后再相加，之后封装成整数对象并返回引用，与直接将整数表示为实现语言的primitive type相比效率天差地别。</li>
</ul>
<p>因此，为了效率考虑，则需要把整数，浮点数等归入primitive type。这样做就又产生了一个问题：在JVM中，一个值即可能是用实现语言的primitive type表示，也可能用指针表示，我们如何对二者进行区分呢？幸好Java是静态类型语言，在编译之后每条指令所操作的值的类型也是确定的。比如当执行iadd指令时栈上存的值就一定为两个整数。但在动态语言中就不一定了，我们必须要先检查类型是否匹配，然后进行操作。此时为了标明一个值究竟是primitive type还是reference type，我们必须把值的高位留出来作为类型tag以示区分。</p>
<div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#7f848e">// 动态语言虚拟机中的一个值往往是这个样子的
</span></span></span><span style="display:flex;"><span><span style="color:#7f848e"></span><span style="color:#c678dd">struct</span> <span style="color:#e06c75">Value_t</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#e06c75">Type</span> <span style="color:#e06c75">type</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#c678dd">union</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e5c07b">double</span> <span style="color:#e06c75">number</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#e5c07b">bool</span> <span style="color:#e06c75">boolean</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#e06c75">HeapObject</span><span style="color:#56b6c2">*</span> <span style="color:#e06c75">object</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#e06c75">data</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="generic">Generic<a hidden class="anchor" aria-hidden="true" href="#generic">#</a></h2>
<p>既然有了primitive type的整数，似乎再也不需要作为对象的整数了？看起来似乎是这样，但是Java却依然提供了Integer类表示作为对象的整数——这主要还是因为为了支持泛型的存在。</p>
<p>Java的泛型是通过<a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">类型擦除</a>实现的，也就是泛型信息只在编译期可见，而在运行期(也就是JVM)不可见。无论你是写成<code>List&lt;String&gt;</code> 还是 <code>List&lt;A&gt;</code> ，它们在编译后都会变成同一个List，而这个List存储的是Object对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#7f848e">// 泛型类：</span>
</span></span><span style="display:flex;"><span><span style="color:#c678dd">public</span> <span style="color:#c678dd">class</span> <span style="color:#e5c07b">Box</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">T</span><span style="color:#56b6c2">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#c678dd">private</span> <span style="color:#e06c75">T</span> <span style="color:#e06c75">t</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#c678dd">public</span> <span style="color:#e5c07b">void</span> <span style="color:#61afef;font-weight:bold">set</span>(<span style="color:#e06c75">T</span> <span style="color:#e06c75">t</span>) { <span style="color:#c678dd">this</span>.<span style="color:#e06c75">t</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">t</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#c678dd">public</span> <span style="color:#e06c75">T</span> <span style="color:#61afef;font-weight:bold">get</span>() { <span style="color:#c678dd">return</span> <span style="color:#e06c75">t</span>; }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#7f848e">// 上面的泛型类在编译成字节码后</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#c678dd">public</span> <span style="color:#c678dd">class</span> <span style="color:#e5c07b">org</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">example</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">Box</span> {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  <span style="color:#c678dd">private</span> <span style="color:#e06c75">Ljava</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">lang</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">Object</span>; <span style="color:#e06c75">t</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#c678dd">public</span> <span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">init</span><span style="color:#56b6c2">&gt;</span>()<span style="color:#e06c75">V</span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#c678dd">public</span> <span style="color:#61afef;font-weight:bold">set</span>(<span style="color:#e06c75">Ljava</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">lang</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">Object</span>;)<span style="color:#e06c75">V</span>
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#c678dd">public</span> <span style="color:#61afef;font-weight:bold">get</span>()<span style="color:#e06c75">Ljava</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">lang</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">Object</span>;
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为实际上用Object存储，所以每次get都是做了一次强制类型转换，Java编译器会生成CHECKCAST指令来保证类型转换时的正确性。</p>
<div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#7f848e">// java代码</span>
</span></span><span style="display:flex;"><span><span style="color:#e06c75">System</span>.<span style="color:#e06c75">out</span>.<span style="color:#e06c75">println</span>(<span style="color:#e06c75">stringBox</span>.<span style="color:#e06c75">get</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#7f848e">// 编译后的字节码</span>
</span></span><span style="display:flex;"><span><span style="color:#e06c75">INVOKEVIRTUAL</span> <span style="color:#e06c75">org</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">example</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">Box</span>.<span style="color:#e06c75">get</span> ()<span style="color:#e06c75">Ljava</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">lang</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">Object</span>;
</span></span><span style="display:flex;"><span><span style="color:#e06c75">CHECKCAST</span> <span style="color:#e06c75">java</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">lang</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">String</span>
</span></span><span style="display:flex;"><span><span style="color:#e06c75">INVOKEVIRTUAL</span> <span style="color:#e06c75">java</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">io</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">PrintStream</span>.<span style="color:#e06c75">println</span> (<span style="color:#e06c75">Ljava</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">lang</span><span style="color:#56b6c2">/</span><span style="color:#e06c75">String</span>;)<span style="color:#e06c75">V</span>
</span></span></code></pre></div><p>但是如果泛型已经由编译器保证没有类型错误，为什么又要加CHECKCAST指令来运行时再次检查呢？考虑如下泛型程序，在可以通过编译，但在运行时CHECKCAST会报错：</p>
<div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#c678dd">public</span> <span style="color:#c678dd">class</span> <span style="color:#e5c07b">Main</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#c678dd">public</span> <span style="color:#c678dd">static</span> <span style="color:#e5c07b">void</span> <span style="color:#61afef;font-weight:bold">main</span>(<span style="color:#e06c75">String</span><span style="color:#56b6c2">[]</span> <span style="color:#e06c75">args</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#e06c75">Box</span> <span style="color:#e06c75">stringBox</span> <span style="color:#56b6c2">=</span> <span style="color:#c678dd">new</span> <span style="color:#e06c75">Box</span><span style="color:#56b6c2">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#e06c75">stringBox</span>.<span style="color:#e06c75">set</span>(<span style="color:#e06c75">5</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#e06c75">foo</span>(<span style="color:#e06c75">stringBox</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#c678dd">public</span> <span style="color:#c678dd">static</span> <span style="color:#e5c07b">void</span> <span style="color:#61afef;font-weight:bold">foo</span>(<span style="color:#e06c75">Box</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">String</span><span style="color:#56b6c2">&gt;</span> <span style="color:#e06c75">box</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#e06c75">System</span>.<span style="color:#e06c75">out</span>.<span style="color:#e06c75">println</span>(<span style="color:#e06c75">box</span>.<span style="color:#e06c75">get</span>() <span style="color:#56b6c2">+</span> <span style="color:#98c379">&#34;123&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#7f848e">//Exception in thread &#34;main&#34; java.lang.ClassCastException: class java.lang.Integer cannot be cast to class //java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader &#39;bootstrap&#39;)</span>
</span></span><span style="display:flex;"><span><span style="color:#7f848e">//	at org.example.Main.foo(Main.java:14)</span>
</span></span><span style="display:flex;"><span><span style="color:#7f848e">//	at org.example.Main.main(Main.java:10)</span>
</span></span></code></pre></div><p>这是因为Java为了让新代码和没有泛型之前(Java8)的代码兼容，而引入了<a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-4.html#jls-4.8">Raw Type</a>，也就是没有泛型参数的泛型——对这种类型的检查会适当放松——代价就是动态检查的开销。</p>
<p>当然泛型不仅仅可以通过类型擦除实现，像C++的模板就是走向了另外一个极端——为每个类型都生成相应的类——这样的缺点自然是代码膨胀，好处却是可以动态获取类型信息(C++是否支持反射暂且不论，但如果Java采取和C++一样泛型机制就一定会支持这样的反射的)，不需要动态类型检查，也不需要像Java一样的Integer类。</p>
<p>好，话题又回到Java的Integer类，正是应为Java的泛型是通过类型擦除实现，所以所有的泛型在背后都有一套统一的表示——也就是Object。但是primitive type却在Java OO继承链之外，也就无法使用泛型了——所有就引入了将primitive type封装成wrapper type的机制。将int封装为Integer即是一个例子。</p>
<h2 id="autoboxing--and-integer-cache">Autoboxing  and Integer Cache<a hidden class="anchor" aria-hidden="true" href="#autoboxing--and-integer-cache">#</a></h2>
<p>虽然已经有了wrapper type，但每次手动封装也是非常麻烦的。所以编译就加入了自动检测类型，在合适的时候将primitive type转化为相应的wrapper type，将wrapper type转化为相应的primitive type的机制，也就是“Autoboxing”与“Unboxing”</p>
<p>所以说，面试题中<code>Integer i = 100;</code>等即采用了Autoboxing 机制，上面的代码在编译处理过之后就等价为下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#e06c75">Integer</span> <span style="color:#e06c75">i</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">Integer</span>.<span style="color:#e06c75">valueOf</span>(<span style="color:#e06c75">100</span>);
</span></span><span style="display:flex;"><span><span style="color:#e06c75">Integer</span> <span style="color:#e06c75">j</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">Integer</span>.<span style="color:#e06c75">valueOf</span>(<span style="color:#e06c75">100</span>);
</span></span><span style="display:flex;"><span><span style="color:#e06c75">System</span>.<span style="color:#e06c75">out</span>.<span style="color:#e06c75">print</span>(<span style="color:#e06c75">i</span> <span style="color:#56b6c2">==</span> <span style="color:#e06c75">j</span>); <span style="color:#7f848e">// true or false?</span>
</span></span></code></pre></div><p>已知引用比较在java中是直接比较地址，那么我们只需要知道<code>Integer.valueOf</code>做了什么就知道面试题的答案了。</p>
<p>查阅 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#valueOf-int-">java doc</a>，发现:</p>
<blockquote>
<div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#c678dd">public</span> <span style="color:#c678dd">static</span> <span style="color:#e06c75">Integer</span> <span style="color:#61afef;font-weight:bold">valueOf</span>(<span style="color:#e5c07b">int</span> <span style="color:#e06c75">i</span>)
</span></span></code></pre></div><p>Returns an <code>Integer</code> instance representing the specified <code>int</code> value. If a new <code>Integer</code> instance is not required, this method should generally be used in preference to the constructor <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#Integer-int-"><code>Integer(int)</code></a>, as this method is likely to yield significantly better space and time performance by caching frequently requested values. This method will always cache values in the range -128 to 127, inclusive, and <strong>may cache other values outside of this range</strong>.</p>
<ul>
<li>
<p><strong>Parameters:</strong></p>
<p><code>i</code> - an <code>int</code> value.</p>
</li>
<li>
<p><strong>Returns:</strong></p>
<p>an <code>Integer</code> instance representing <code>i</code>.</p>
</li>
<li>
<p><strong>Since:</strong></p>
<p>1.5</p>
</li>
</ul>
</blockquote>
<p>所以说，除开根据Integer类的实现不同会有不同表现，如果只看标准类库的话那么面试题还没问题的，缓存值的Integer Cache大小总是大于256。但注意到 java doc 中说“may cache other values outside of this range”，这也许就说明还有调节的空间？果然，经查阅，<code>-XX:AutoBoxCacheMax</code> 选项就可以调节Integer Cache的大小。</p>
<p>在我本机的Open jdk19中，<code>Integer.valueOf</code>实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>	<span style="color:#61afef">@IntrinsicCandidate</span>
</span></span><span style="display:flex;"><span>    <span style="color:#c678dd">public</span> <span style="color:#c678dd">static</span> <span style="color:#e06c75">Integer</span> <span style="color:#61afef;font-weight:bold">valueOf</span>(<span style="color:#e5c07b">int</span> <span style="color:#e06c75">i</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#c678dd">if</span> (<span style="color:#e06c75">i</span> <span style="color:#56b6c2">&gt;=</span> <span style="color:#e06c75">IntegerCache</span>.<span style="color:#e06c75">low</span> <span style="color:#56b6c2">&amp;&amp;</span> <span style="color:#e06c75">i</span> <span style="color:#56b6c2">&lt;=</span> <span style="color:#e06c75">IntegerCache</span>.<span style="color:#e06c75">high</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#c678dd">return</span> <span style="color:#e06c75">IntegerCache</span>.<span style="color:#e06c75">cache</span><span style="color:#56b6c2">[</span><span style="color:#e06c75">i</span> <span style="color:#56b6c2">+</span> (<span style="color:#56b6c2">-</span><span style="color:#e06c75">IntegerCache</span>.<span style="color:#e06c75">low</span>)<span style="color:#56b6c2">]</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#c678dd">return</span> <span style="color:#c678dd">new</span> <span style="color:#e06c75">Integer</span>(<span style="color:#e06c75">i</span>);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>而用到的<code>IntegerCache</code>类实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#c678dd">private</span> <span style="color:#c678dd">static</span> <span style="color:#c678dd">class</span> <span style="color:#e5c07b">IntegerCache</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#c678dd">static</span> <span style="color:#c678dd">final</span> <span style="color:#e5c07b">int</span> <span style="color:#e06c75">low</span> <span style="color:#56b6c2">=</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">128</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#c678dd">static</span> <span style="color:#c678dd">final</span> <span style="color:#e5c07b">int</span> <span style="color:#e06c75">high</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#c678dd">static</span> <span style="color:#c678dd">final</span> <span style="color:#e06c75">Integer</span><span style="color:#56b6c2">[]</span> <span style="color:#e06c75">cache</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#c678dd">static</span> <span style="color:#e06c75">Integer</span><span style="color:#56b6c2">[]</span> <span style="color:#e06c75">archivedCache</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#c678dd">static</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#7f848e">// high value may be configured by property</span>
</span></span><span style="display:flex;"><span>            <span style="color:#e5c07b">int</span> <span style="color:#e06c75">h</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">127</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#e06c75">String</span> <span style="color:#e06c75">integerCacheHighPropValue</span> <span style="color:#56b6c2">=</span>
</span></span><span style="display:flex;"><span>                <span style="color:#e06c75">VM</span>.<span style="color:#e06c75">getSavedProperty</span>(<span style="color:#98c379">&#34;java.lang.Integer.IntegerCache.high&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#c678dd">if</span> (<span style="color:#e06c75">integerCacheHighPropValue</span> <span style="color:#56b6c2">!=</span> <span style="color:#e5c07b">null</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#c678dd">try</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#e06c75">h</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">Math</span>.<span style="color:#e06c75">max</span>(<span style="color:#e06c75">parseInt</span>(<span style="color:#e06c75">integerCacheHighPropValue</span>), <span style="color:#e06c75">127</span>);
</span></span><span style="display:flex;"><span>                    <span style="color:#7f848e">// Maximum array size is Integer.MAX_VALUE</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#e06c75">h</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">Math</span>.<span style="color:#e06c75">min</span>(<span style="color:#e06c75">h</span>, <span style="color:#e06c75">Integer</span>.<span style="color:#e06c75">MAX_VALUE</span> <span style="color:#56b6c2">-</span> (<span style="color:#56b6c2">-</span><span style="color:#e06c75">low</span>) <span style="color:#56b6c2">-</span><span style="color:#e06c75">1</span>);
</span></span><span style="display:flex;"><span>                } <span style="color:#c678dd">catch</span>( <span style="color:#e06c75">NumberFormatException</span> <span style="color:#e06c75">nfe</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#7f848e">// If the property cannot be parsed into an int, ignore it.</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#e06c75">high</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">h</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#7f848e">// Load IntegerCache.archivedCache from archive, if possible</span>
</span></span><span style="display:flex;"><span>            ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#7f848e">// Use the archived cache if it exists and is large enough</span>
</span></span><span style="display:flex;"><span>             ...
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>            <span style="color:#7f848e">// range [-128, 127] must be interned (JLS7 5.1.7)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#c678dd">assert</span> <span style="color:#e06c75">IntegerCache</span>.<span style="color:#e06c75">high</span> <span style="color:#56b6c2">&gt;=</span> <span style="color:#e06c75">127</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>再追踪调用链可以发现VM类表示VM的各种选项，均有System类中的方法设置，但System类中方法又由谁调用，并从哪里知道参数呢？再追踪就会发现，果然这些命令行参数的解析和传入都是通过native method来实现的。</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://rzyn2020.github.io/tags/java/">Java</a></li>
      <li><a href="https://rzyn2020.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://rzyn2020.github.io/posts/scheme%E6%8B%BE%E9%81%97/">
    <span class="title">« Prev</span>
    <br>
    <span>Scheme 拾遗：S-Expression，Continuation 以及 Macro</span>
  </a>
  <a class="next" href="https://rzyn2020.github.io/posts/%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E4%BB%BB%E5%8A%A1/">
    <span class="title">Next »</span>
    <br>
    <span>编译器的结构与任务</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Autoboxing and IntegerCache in Java on x"
            href="https://x.com/intent/tweet/?text=Autoboxing%20and%20IntegerCache%20in%20Java&amp;url=https%3a%2f%2frzyn2020.github.io%2fposts%2fautoboxing-and-integercache-in-java%2f&amp;hashtags=java%2c%e9%9d%a2%e8%af%95">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Autoboxing and IntegerCache in Java on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frzyn2020.github.io%2fposts%2fautoboxing-and-integercache-in-java%2f&amp;title=Autoboxing%20and%20IntegerCache%20in%20Java&amp;summary=Autoboxing%20and%20IntegerCache%20in%20Java&amp;source=https%3a%2f%2frzyn2020.github.io%2fposts%2fautoboxing-and-integercache-in-java%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Autoboxing and IntegerCache in Java on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2frzyn2020.github.io%2fposts%2fautoboxing-and-integercache-in-java%2f&title=Autoboxing%20and%20IntegerCache%20in%20Java">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Autoboxing and IntegerCache in Java on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frzyn2020.github.io%2fposts%2fautoboxing-and-integercache-in-java%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Autoboxing and IntegerCache in Java on whatsapp"
            href="https://api.whatsapp.com/send?text=Autoboxing%20and%20IntegerCache%20in%20Java%20-%20https%3a%2f%2frzyn2020.github.io%2fposts%2fautoboxing-and-integercache-in-java%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Autoboxing and IntegerCache in Java on telegram"
            href="https://telegram.me/share/url?text=Autoboxing%20and%20IntegerCache%20in%20Java&amp;url=https%3a%2f%2frzyn2020.github.io%2fposts%2fautoboxing-and-integercache-in-java%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Autoboxing and IntegerCache in Java on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Autoboxing%20and%20IntegerCache%20in%20Java&u=https%3a%2f%2frzyn2020.github.io%2fposts%2fautoboxing-and-integercache-in-java%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://rzyn2020.github.io/"></a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
