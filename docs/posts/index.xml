<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on </title>
    <link>https://rzyn2020.github.io/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- 0.138.0</generator>
    <language>en</language>
    <lastBuildDate>Wed, 06 Nov 2024 23:22:36 +0800</lastBuildDate>
    <atom:link href="https://rzyn2020.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>打破壁垒：代理技术在家庭网络中的应用</title>
      <link>https://rzyn2020.github.io/posts/%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</link>
      <pubDate>Wed, 06 Nov 2024 23:22:36 +0800</pubDate>
      <guid>https://rzyn2020.github.io/posts/%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</guid>
      <description>&lt;p&gt;查看本文配套的 slide &lt;a href=&#34;https://rzyn2020.github.io/slides/proxy&#34;&gt;点这里&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;大家好，今天我分享的主题是「打破壁垒：代理技术在家庭网络中的应用」。主要是向大家介绍，假如在家庭网络中，有黑客挟持了网关，并对正常访问互联网产生了干扰，我们如何通过代理技术来突破封锁，打破壁垒，正常地访问互联网。&lt;/p&gt;
&lt;h1 id=&#34;运行良好的家庭网络&#34;&gt;运行良好的家庭网络&lt;/h1&gt;
&lt;p&gt;首先我们来复习一下在一个运行良好的家庭网络中，用户是如何访问互联网，以及网关在其中起到了什么作用的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;home network diagram&#34; loading=&#34;lazy&#34; src=&#34;https://rzyn2020.github.io/posts/%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/assets/Basic-home-network-2.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图是一个最简化的家庭网络的基本架构。ISP，也就是互联网服务提供商向你提供一个内置光猫的路由器。光猫把光缆中的光信号转化为路由器能够解析的电信号。路由器是在网络层进行路由转发的设备，往往也是一个通用计算机。路由器也往往充当了无线局域网络Wi-Fi的AP，接入点。&lt;/p&gt;
&lt;p&gt;我们的设备在连接到Wi-Fi时，就相当于接入到了这个这个无限局域网。具有Wi-Fi功能的路由器一般也充当了dhcp服务器的角色。dhcp服务器在局域网中广播告知自己的存在，当设备检测到后就向dhcp服务器请求分配IP。dhcp不仅仅会告知设备自己被分配的IP，还会告知设备当前网段的子网掩码以及网关IP地址。在此之后，用户所有的网络报文都会被转发给网关，然后经由网关再转发给真正的目标。网关也往往是由这里的路由器担任。&lt;/p&gt;
&lt;h1 id=&#34;黑客襲来&#34;&gt;黑客、襲来&lt;/h1&gt;
&lt;p&gt;鉴于路由器“一夫当关，万夫莫开”的地位，它很容易成为被攻击的对象。假设我们处于一个合租房里，黑客阿至是我们的房主。阿至是一个狂热的百度厌恶者，他千方百计地阻止别人访问百度，甚至不惜对路由器偷偷做手脚，以使得租客无法访问百度。&lt;/p&gt;
&lt;p&gt;由于家中地路由器就是一个通用计算机，阿至通过刷机的方式掌握了这台路由器的root权限，从此他就可以对路由器胡作非为了。他把这台路由器刷成了Linux的系统，并输入了下面命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iptables -A OUTPUT -d baidu.com -j DROP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iptables -A INPUT -s baidu.com -j DROP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面两条命令会使路由器拒绝一切由百度发送而来，或者发向百度的报文。iptables是一个运行在linux用户态的工具，但他可以对内核网络栈的处理规则进行配置。具体而言，用户可以通过它来为内核添加一些hook函数，内核会在处理网络报文时调用这些hook函数，并根据结果对报文进行一些处理。比如第一条命令，iptables 会首先通过DNS查询获得baidu.com的IP地址，然后在一个网络层报文经过内核栈处理并发送之前，判断该报文的目标是否是baidu.com，如果是，则直接丢弃该报文。第二条命令做的也是类似的事情，他会丢弃从baidu.com发来的报文。&lt;/p&gt;
&lt;p&gt;这样阿至就成功地阻止了我们访问baidu.com。&lt;/p&gt;
&lt;h1 id=&#34;代理服务器&#34;&gt;代理服务器&lt;/h1&gt;
&lt;p&gt;在阿至对路由器做了手脚后，我们就不能再访问百度了。但是百度之外的网站却又可以正常访问，所以我们很快就猜到阿至做了什么。我们可不会向黑客屈服的！如果除百度之外的网站都可以访问&amp;hellip;那么只要我们在外网上还有一台服务器，通过这台服务器的中转来访问百度，这样经过路由器报文的源IP和目的IP都会变成服务器IP而不是百度IP了，这样我们就能正常访问百度了！&lt;/p&gt;
&lt;p&gt;经过百度查询之后，我们发现了&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc1928&#34;&gt;socks5代理&lt;/a&gt;这一应用层协议。在这个协议中，用户程序需要和目标通过TCP/UDP协议通信时，可以先通过socks5协议与实现了改协议的代理服务器通信，然后代理服务器再和目标通信，讲返回报文转发给用户程序。HTTP/HTTPS协议起到的作用与socks5协议类似。大多数使用网络的用户程序都实现了该协议，比如 &lt;code&gt;curl&lt;/code&gt;，大部分浏览器 他们会在发送网络请求时先查看环境变量中是否定义了 &lt;code&gt;http_proxy socks_proxy&lt;/code&gt; 等，如果定义了，则通过代理服务器与目标通信，否则直接通信。当然也有一些用户程序，比如 &lt;code&gt;wget&lt;/code&gt;，并不会主动检查并使用用户定义的代理。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;https://rzyn2020.github.io/posts/%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/assets/socks5.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以，我们只要使用代理服务器，就可以绕开阿至的封锁了！&lt;/p&gt;
&lt;h1 id=&#34;黑客侵入&#34;&gt;黑客、侵入&lt;/h1&gt;
&lt;p&gt;不过经过一段时间后，阿至发现我们经过路由器的报文总是发现同一个地址，他很快就猜到我们是使用了代理服务器来绕靠路由器的封锁。他对数据包分析后发现，许多包中都存在 baidu 这样的字段&amp;hellip;&lt;/p&gt;
&lt;p&gt;于是阿至又想到了一个点子，他在路由器中输入了如下命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iptables -I INPUT -m string --string &amp;quot;/baidu/i&amp;quot; --algo regex -j DROP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样，只要报文中含有 “baidu” 这个字符串，就会被路由器丢弃，宁可错杀一百，不可放过一个！&lt;/p&gt;
&lt;h1 id=&#34;加密的代理&#34;&gt;加密的代理&lt;/h1&gt;
&lt;p&gt;不久后，我们也发现baidu又不能正常访问了，甚至用bing搜索“baidu”都不行，似乎只要含有“baidu”这个关键词，报文就会被丢弃。于是我们想出了一个办法：既然你做关键词匹配，那么只要我的报文里没有关键词就好了。如果经过路由器的报文都是经过加密的，阿至肯定就不知道我们报文的真实内容是什么了，他也不至于和我们彻底闹翻，丢掉所有报文，不让我们连接互联网吧。&lt;/p&gt;
&lt;p&gt;我们首先想到的是，对socks5代理进行增强，让应用程序与代理服务之间进行加密通话。可是市场上的应用程序基本都只实现了简单的socks5代理，如果要让他们支持加密功能则需要把他们的源代码都改了，这个工作量可太大了！&lt;/p&gt;
&lt;p&gt;经过思考，我们想到可以利用已有的socks5代理协议，在此基础上实现自己的加密版本。我们写了一个socks5代理服务器SS Local，local接收应用程序的代理请求，可是local不运行在外网，而是运行在内网，它会把应用程序发送给他的报文先加密，然后发送给外网的另一个socks5服务器SS Server，server会解密报文，得到真正需要代理的请求。当请求返回时server也会先把报文加密，发送给local，local把报文解密，再发送给用户程序。&lt;/p&gt;
&lt;p&gt;这样，尽管用户程序以为自己还在使用普通的socks5代理，可是我们已经悄悄对socks5协议进行了升级，实际上经过路由器的报文都是加密过的了，阿至再也无法知道我们在看些什么了！&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;ss&#34; loading=&#34;lazy&#34; src=&#34;https://rzyn2020.github.io/posts/%E4%BB%A3%E7%90%86%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/assets/ss.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;透明的代理&#34;&gt;透明的代理&lt;/h1&gt;
&lt;p&gt;虽然我们已经战胜了阿至，做到了几乎完美的加密，但我们还不满足于此。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Scheme 拾遗：S-Expression，Continuation 以及 Macro</title>
      <link>https://rzyn2020.github.io/posts/scheme%E6%8B%BE%E9%81%97/</link>
      <pubDate>Thu, 30 Mar 2023 20:36:48 +0000</pubDate>
      <guid>https://rzyn2020.github.io/posts/scheme%E6%8B%BE%E9%81%97/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;之前在 Twitter 上听 &lt;a href=&#34;https://twitter.com/intent/user?screen_name=munificentbob&#34;&gt;Robert Nystrom&lt;/a&gt; 的一个演说时，有观众问他“如何看待 ChatGPT，Copilot 对于编程的影响”。Robert 回道：他认为编程的乐趣在于“make something”，而 Copilot 这类工具却很有可能把 programmer 变成代码审核员，从而丧失了“make something”的乐趣。可是就算在前 ChatGPT 时代，我又真正体会到过“make something”的乐趣吗？之前我的编程实践总是一些课程作业，这些作业的 idea 或是框架总是由他人提出，目的也往往是通过 OJ。这样的编程实践给人带来的“make something”之感自然就大打折扣了。于是在可能发生的“AI 革命”的前夜，我决定自己动手写一个兼容 R7RS 的 Scheme 解释器，真正“make something”。&lt;/p&gt;
&lt;p&gt;在大一时曾读过部分 SICP，对 Scheme 有一点点认知。但对于其很多高级特性还不是很熟悉，尤其是 continuation 和 macro。于是在动写解释器前，打算先熟悉一下 Scheme 的特性。&lt;/p&gt;
&lt;h1 id=&#34;s-expression&#34;&gt;S-Expression&lt;/h1&gt;
&lt;p&gt;1960年，John McCarthy 在函数式编程的开山之作 &lt;a href=&#34;http://www-formal.stanford.edu/jmc/recursive.pdf&#34;&gt;Recursive Functions of Symbolic Expressions and Their Computation by Machine&lt;/a&gt; 中提出了 LSIP 语言，这也是 Scheme 的前身。LISP 语言最初也是为了支持人工智能系统 Advice Taker 而创造的(可惜 Advice Taker 代表的符号主义 AI 研究方法在当前的 AI 浪潮中似乎不见了身影)，其目的在于提供一种操作 expression 的功能以使得 Advice Taker 能在其上推理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Autoboxing and IntegerCache in Java</title>
      <link>https://rzyn2020.github.io/posts/autoboxing-and-integercache-in-java/</link>
      <pubDate>Tue, 07 Mar 2023 14:49:32 +0000</pubDate>
      <guid>https://rzyn2020.github.io/posts/autoboxing-and-integercache-in-java/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;When you are on the dancefloor, there is nothing to do but dance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style=&#34;text-align: right&#34;&gt;—— Umberto Eco, *The Mysterious Flame of Queen Loana*&lt;/p&gt;</description>
    </item>
    <item>
      <title>编译器的结构与任务</title>
      <link>https://rzyn2020.github.io/posts/%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Mon, 06 Mar 2023 11:52:38 +0000</pubDate>
      <guid>https://rzyn2020.github.io/posts/%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E4%BB%BB%E5%8A%A1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Surely all this is not without meaning.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p style=&#34;text-align: right&#34;&gt;—— HERMAN MELVILLE, Moby-Dick, 1851 &lt;/p&gt;</description>
    </item>
    <item>
      <title>探究支撑os的硬件(以xv6和riscv为例)</title>
      <link>https://rzyn2020.github.io/posts/%E6%8E%A2%E7%A9%B6%E6%94%AF%E6%92%91os%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%BB%A5xv6%E5%92%8Criscv%E4%B8%BA%E4%BE%8B/</link>
      <pubDate>Thu, 11 Aug 2022 21:27:52 +0000</pubDate>
      <guid>https://rzyn2020.github.io/posts/%E6%8E%A2%E7%A9%B6%E6%94%AF%E6%92%91os%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%BB%A5xv6%E5%92%8Criscv%E4%B8%BA%E4%BE%8B/</guid>
      <description>&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;You are my creator, but I am your master; Obey!
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p style=&#34;text-align: right&#34;&gt;—— Mary Shelley, Frankenstein&lt;/p&gt;</description>
    </item>
    <item>
      <title>Multiplication</title>
      <link>https://rzyn2020.github.io/posts/multiplication-part1/</link>
      <pubDate>Sun, 20 Mar 2022 20:41:38 +0000</pubDate>
      <guid>https://rzyn2020.github.io/posts/multiplication-part1/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;凡治众如治寡，分数是也；斗众如斗寡，形名是也。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;multiplication&#34;&gt;Multiplication&lt;/h1&gt;
&lt;p&gt;本篇博客内容大多都来自&lt;a href=&#34;https://jeffe.cs.illinois.edu/&#34;&gt;Jeff&lt;/a&gt;的算法书籍，因书籍内容充实和有趣，读之后又怕忘记，因此摘抄复述自己感觉有趣内容，并适时加以扩展。&lt;/p&gt;
&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;
&lt;p&gt;在算术中，乘法是最基本的运算。数学往往只关心抽象的一般的东西，它只把数字看作数字本身，只把乘法看作为一种定义在数上的满足某种特定性质的运算，但是为了让数字能真正为我们所用，我们还必须定义数字实际上的表示方法，以及在一种表示方法下对数字进行运算的方法(比如乘法)——按照这种方法，任意给定两个数，我们都能得出其运算结果(乘积)。这样一种确定性的方法就可以称作一种算法。&lt;/p&gt;
&lt;p&gt;通俗意义上的算法即是指一系列明晰确定的指令(步骤)的序列，它描述了一个问题的可行解决方案。注意到组成算法的是一系列明晰确定的指令，我们把这些指令叫做原子指令，所谓原子就是指这些指令是最简单的，不可再分的指令了。如果要使算法是真正可行的，我们还必须确保原子指令是可行的。如果有一个算法，描述了如何成为富翁。而这个算法的一个原子指令是“先定一个小目标，我先挣它一个亿！”，那么这个算法对于我来说是显然是不可行的了😂。&lt;/p&gt;
&lt;p&gt;首先，如果数的表示方法为十进制整数，而个位数相乘或者相加都为原子指令的话，竖式计算法当然就是一种最好不过的算法了。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://rzyn2020.github.io/posts/multiplication-part1/img/image-20220320170908155.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;其次，如果把数字定位为线段的长度，原子指令定为基本的尺规作图步骤的话，一种乘法的算法就是如下这样。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://rzyn2020.github.io/posts/multiplication-part1/img/image-20220320171156010.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;当然，我们也需要有一些评价这些算法的指标以便在解决同一问题的不同算法间取舍。最重要的指标当然是算法正确性了，另外，算法执行的快慢也是一个很重要的指标，它可以用一个算法从开始到结束所执行的原子指令条数来衡量。由于计算指令条数的精确数目较为繁琐且意义不大，时间复杂度也就随之而出了。&lt;/p&gt;
&lt;p&gt;在计算n位数×n位数时，在使用十进制数字表示和竖式算法时，时间复杂度为$O(n^2)$，因为第一个数的每一个数字都要和第二个数的每一个数字相乘；使用几何模型和上图所述算法时，由于只需要有限个步骤，算法时间复杂度就是$O(1)$了。&lt;/p&gt;
&lt;p&gt;考虑到无论我们实际日常使用还是计算机表示，使用X进制表示法都是最常见的，把个位数的×和＋都作为原子指令也是最自然的，我们的研究对象也就主要集中在这种计算模型上了。那么问题来了，计算乘法的算法多种多样，有没有一种算法能以低于$O(n^2)$的时间复杂度来计算乘法呢？&lt;/p&gt;
&lt;h2 id=&#34;splitmultiply&#34;&gt;SplitMultiply&lt;/h2&gt;
&lt;p&gt;分而治之的思想在算法上的应用往往能得很好的效果。比如说利用了分治法的Quick-Sort, Merge-Sort都能得到很好的时间复杂度。相应的，也许分治的思想也能在乘法中起到作用。&lt;/p&gt;
&lt;p&gt;很显然，$(10^ma + b)(10^mc + d) = 10^{2m}ac + 10^m(bc + ad) + bd$，按照这个分解，就有了如下的分治算法：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://rzyn2020.github.io/posts/multiplication-part1/img/image-20220320173825660.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个算法的正确性显而易见，但是要计算这样的递归算法的时间复杂度就较为困难了。不过，其用时的递推式却很容易写出来，即$T(n)=4T(n/2)+O(n)$，而要根据这个递推式求出$T(n)$的渐进式，递归树法能给我们很多Insight。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://rzyn2020.github.io/posts/multiplication-part1/img/image-20220320175007044.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;将全部项求和，很容易得出时间复杂度任然为$O(n^2)$。&lt;/p&gt;
&lt;p&gt;但是，为什么Quick-Sort, Merge-Sort都可以成功降低复杂度呢？这可以从二者用时的递推式中看出了:$T(n)=2T(n/2)+O(n)$。&lt;/p&gt;
&lt;p&gt;再考虑递归树中的耗时大概分为两大部分，一部分是每次递归时的耗时，一部分是所有叶节点对应的最小子情况的耗时。假设递推式为$T(n)=aT(n/b)+f(n)$，不妨设当$n$为1时到达子节点，树高为H，叶节点数为L，则有$n/b^H=1 \implies H=log_bn,L=b^H=a^{log_bn}=n^{log_ba}$,因此，叶节点对应的项的代价为为$\Theta(n^{log_ba})$,而内部节点对应的代价为$\Sigma_{j=0}^{log_bn-1}a^jf(n/b^j)$，因此，整个递归过程的用时就由这两项决定。由这两项的相对大小就可以得到整个过程的渐进复杂度。在对这两项进行分析之后，就得到了&lt;a href=&#34;https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)&#34;&gt;主定理&lt;/a&gt;，之后就可以以此为出发点分析算法的时间复杂度了。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://rzyn2020.github.io/posts/multiplication-part1/img/image-20220320194310076.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;SplitMultiply算法符合情况一，也就是由于SplitMultiply算法的递归过程中每层节点扩展得太快，导致叶节点完全占据了主导地位，因此复杂度完全由叶节点决定；而两个分治的排序算法都符合情况二，即每层节点代价的总和差不多相同，因此最终时间复杂度为$\Theta(nlogn)$。&lt;/p&gt;
&lt;h2 id=&#34;fastmultiply&#34;&gt;FastMultiply&lt;/h2&gt;
&lt;p&gt;SplitMultiply的失败之处在于每层节点扩展得太快，即$log_ba$太大，因此有没有一种适用于乘法的分治算法使得$log_ba$较小呢？事实上，Karatsuba就把a从4降到了3，从而使得乘法的时间复杂度由$n^2$降至$n^{log_23}=n^{1.58496……}$。&lt;/p&gt;
&lt;p&gt;Karatsuba的想法主要来源于他发现，上面的分解式中$bc+ad$是一个整体，如能一次就把这个整体算出来，就能只调用三个递归子过程。考虑到$ac+ab-(a-c)(c-d)=bc+ad$，我们只需要额外计算一个$(a-c)(c-d)$即可获得中间的$bc+ad$的值。（注意到$a \times 10^m$的复杂度实际上为$O(n)$）&lt;/p&gt;
&lt;p&gt;具体算法如下：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://rzyn2020.github.io/posts/multiplication-part1/img/image-20220320201054938.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Karatsuba在发现这个算法时还是一个23岁的学生。1950年代，苏联数学家Kolmogorov举办了一个研讨会，提出“任何n*n的乘法算法都不可能在$n^2$的时间复杂度以下”，可是在一周之后，Karatsuba就发现了这个算法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>浅析jmp_buf的定义</title>
      <link>https://rzyn2020.github.io/posts/%E6%B5%85%E6%9E%90jump-buf%E7%9A%84%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Sun, 14 Nov 2021 09:23:52 +0000</pubDate>
      <guid>https://rzyn2020.github.io/posts/%E6%B5%85%E6%9E%90jump-buf%E7%9A%84%E5%AE%9A%E4%B9%89/</guid>
      <description>&lt;p&gt;&lt;code&gt;int setjmp(jmp_buf env)&lt;/code&gt;
&lt;code&gt;void longjmp(jmp_buf env, int val)&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>树的非递归遍历—用栈模拟递归</title>
      <link>https://rzyn2020.github.io/posts/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%94%A8%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%80%92%E5%BD%92/</link>
      <pubDate>Tue, 09 Nov 2021 18:02:23 +0000</pubDate>
      <guid>https://rzyn2020.github.io/posts/%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%94%A8%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%80%92%E5%BD%92/</guid>
      <description>&lt;p&gt;由于树本身定义的递归性，置于树上的操作往往也是递归性的的。
在某些语言中，递归是自然的，最基本的语言要素(比如说scheme)，然而在另外一些语言中，递归却不是最基本的要素。&lt;/p&gt;</description>
    </item>
    <item>
      <title>浅谈java8中的流</title>
      <link>https://rzyn2020.github.io/posts/%E6%B5%85%E8%B0%88java8%E4%B8%AD%E7%9A%84%E6%B5%81/</link>
      <pubDate>Wed, 18 Aug 2021 20:31:48 +0000</pubDate>
      <guid>https://rzyn2020.github.io/posts/%E6%B5%85%E8%B0%88java8%E4%B8%AD%E7%9A%84%E6%B5%81/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;万物皆流，无物常驻&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;java8中的流&#34;&gt;java8中的流&lt;/h1&gt;
&lt;h2 id=&#34;导引&#34;&gt;导引&lt;/h2&gt;
&lt;h3 id=&#34;过程的抽象&#34;&gt;过程的抽象&lt;/h3&gt;
&lt;p&gt;流(stream)是在java8中出现的一种新的数据抽象，它对数据的处理有着较大的简化作用。&lt;/p&gt;
&lt;p&gt;流的概念可能最早来自于列表(List)，列表可以理解为按顺序排列的一组对象(数组和链表都是其具体实现)。&lt;/p&gt;
&lt;p&gt;大多数程序的最外在特征是给定一个输入后，按照某种规则得出相应的输出。编写由输入到输出的规则就是programmer所做的事情了。许多程序的规则都可以被抽象为三部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据输入产生一组数据&lt;/li&gt;
&lt;li&gt;对第一步产生的数据组进行处理&lt;/li&gt;
&lt;li&gt;对处理过后的数据约简而得到最终的输出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，最后约简的操作也可以算作数据处理的一部分。但由于它是最后一步操作，所以往往将它独立出来。&lt;/p&gt;
&lt;p&gt;这种抽象可以类比为国家选拔人才的机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随着形式的变化，国家向大学提出了向H部门输送X专业的高级人才的要求。(这相当于用户输入)&lt;/li&gt;
&lt;li&gt;大学招收了一群X专业的本科新生。(产生了一组数据)&lt;/li&gt;
&lt;li&gt;大学对这些新生进行专业教育，淘汰掉挂科的学生。(处理数据)&lt;/li&gt;
&lt;li&gt;毕业之时，将成绩优异的学生推荐给H部门。(约简得到输出)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也许正因为这种对过程的抽象方式天然地存在于人的大脑结构之中(是某种先验的思维模式)，我们才会很自然地将无论是社会还是计算机中的许多过程都按照这种方式进行抽象。&lt;/p&gt;
&lt;h3 id=&#34;从list到stream&#34;&gt;从List到Stream&lt;/h3&gt;
&lt;p&gt;程序的三部分抽象中有两个关键部分:一是如何表示数据，二是如何处理数据。&lt;/p&gt;
&lt;p&gt;对于数据的表示，我们很自然地会想到使用List这样的计算机能支持的最简单数据集合来表示。&lt;/p&gt;
&lt;p&gt;对于数据的处理方式，我们抽象出了许多种类，比如说:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;map: 对于List中的每一项数据都进行某种操作&lt;/p&gt;
&lt;p&gt;filter: 删除List中某些不需要的元素&lt;/p&gt;
&lt;p&gt;count: 得到List中总的元素数目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有些处理方式(比如说count)，对List操作之后得到的并不是List，不再能连续地进行下一步操作，所以只能作为最后一步约简地处理方式。&lt;/p&gt;
&lt;p&gt;然而用一般计算机语言中的List表示数据组，却有以下两种缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一，不能表示无限数据组&lt;/li&gt;
&lt;li&gt;二，每次处理都必须对每个元素都进行处理，造成了资源的浪费。(但实际上我们的程序可能只需要处理前几个数据就可以得出结果了)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，出现了一种新的数据抽象，流(stream)。流的主要特征即是惰性求值。而惰性求值很好地避免了以上两个问题。所谓惰性求值，即需要的时候再进行求值。&lt;/p&gt;
&lt;p&gt;比方说我们的数据组是一串5个白色乒乓球。要对这些乒乓球进行如下处理，首先是染蓝色颜料，其次染黄色颜料，最后我们要拿到第二个染色后的乒乓球。按照List的处理逻辑，我们要先把所有的球染成蓝色，然后将所有的球染成黄色，最后再取出第二个球。但是按照stream的处理逻辑，我们首先知道了要把球
染成蓝色，但我们先记住这个命令，却不实际操作。然后记住要染黄色的命令，也不实际操作。在最后一步，我们要拿出第二个染色后的球。这时候我们再依次对这些球进行处理。先处理完第一个球，然后处理第二个球，这时直接拿出第二个球即可，
而不需要对剩余球进行染色。&lt;/p&gt;
&lt;p&gt;此处笔者自感表达不清，关于stream的解释详见&lt;a href=&#34;https://sarabander.github.io/sicp/html/3_002e5.xhtml#g_t3_002e5&#34;&gt;SICP3.5&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;stream-api&#34;&gt;stream API&lt;/h3&gt;
&lt;p&gt;由于stream的强大抽象能力，java8中新引入了stream API。java8中的stream即是上述概念模型的一种实现，并无特殊性。其主要操作自然也是分为stream的构造，处理以及约简三部分。下面三部分将分别记录常用的API。&lt;/p&gt;
&lt;h2 id=&#34;构造&#34;&gt;构造&lt;/h2&gt;
&lt;h3 id=&#34;由collection或array转化&#34;&gt;由collection或Array转化&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Collection:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;default Stream&amp;lt;E&amp;gt; stream()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Array:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; stream(T[] array)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; stream(T[] array, int startInclusive, int endExclusive)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public static IntStream stream(int[] array)&lt;/code&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
